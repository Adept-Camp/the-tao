<!doctype html>
<title>The TAO</title>
<pre>

THE TRULY AUTONOMOUS ORGANIZATION
=================================

"The TAO" is a foundational framework for building DAOs, itself built using the
dappsys framework. It is not monolithic: it's up to you to either deploy your
own instance and grow it into something noteworthy, or to find a way to join an
existing instance.

Each instance has its own tokens, aims, and membership requirements. Each
instance's tokens may be exchanged via any exchange or contract with ERC20 token
support. Each instance is autonomous.

Starting a "The TAO" instance gets you:

* The ability to issue ERC20 tokens.
* The ability to add and remove members.
* The ability to make and vote on proposals.
* The ability to add-on and expand in any direction.


STRUCTURE
=========

Within both dappsys and "The TAO", sensitive functions are protected by an
`auth` modifier. Each "The TAO" instance has a single DSBasicAuthority instance
called the "root authority." Functions guarded by an `auth` modifier in "The
TAO" instances can only be called by contracts and accounts that have been given
permission to do so via the `setCanCall` function on the root authority.

The `setCanCall` function takes first the address which will be calling the
protected function, the address of the contract with the protected function, the
4-byte signature of the protected function, and a boolean indicating whether to
allow or disallow calling the function. By default, protected functions cannot
be called. If a contract or address calls a protected function which it does not
have permission to call, then the protected function throws.

The DSBasicAuthority is itself governed by the dappsys authority system.
Contracts using the dappsys authority system can either be in "authority" mode,
in which case protected functions work as discussed in the above paragraph, or
in "owner" mode, in which case the contract's `_authority` address (and only its
`_authority` address) may call any of the contract's protected functions.

The root authority's authority is a DSEasyMultisig instance, which provides
n-of-m voting on proposals. The root authority itself is in "owner" mode, so the
DSEasyMultisig instance may call any function on the root authority. Proposals
consist of transactions which will be sent by the multisig to the given target
if n-of-m members confirm and then trigger it within the voting window set when
the multisig was deployed.

Every component in "The TAO", except for the multisig, is governed by the root
authority via the dappsys authority system.

The token system consists of a DSTokenFrontend instance which implements the
ERC20 interface and acts as a thin wrapper around a DSTokenController instance.
The DSTokenController instance has a DSBalanceDB instance which keeps track of
each address' token balance and a DSApprovalDB instance which keeps track of
allowances between addresses. This structure allows for easy changing of token
logic in the event a bug is discovered without any risk of losing balances or
allowances.

For token issuance, a DSTokenSupplyManager instance is also provided. New tokens
may be issued to a caller using the `demand` function. This function may be used
by contracts in conjunction with proposals granting such contracts the necessary
permissions to issue pre-determined numbers of tokens to pre-determined
addresses in a trustless manner. More concretely, one may write a contract which
calls `demand` to grant itself some number of tokens and then send the tokens on
to other addresses and then self-destruct or otherwise lock itself out of
executing again. The multisig holders at that point may review the deployed
contract's code and opt to grant it the necessary permissions to call `demand`
on the supply manager. At that point the contract may be executed and the
beneficiaries will receive their requested tokens.

An ad-hoc ASCII art diagram of the structure described above:

                        ------------------
                       |  DSEasyMultisig  |
                        ------------------
                                |
                           (owner of)
                                |
                        ------------------
                       | DSBasicAuthority |
                        ------------------
                                |
     ---------------------(authority of)
    |                     /  |  |  |  \
    |   -----------------    |  |  |   \
    |  | DSTokenFrontend |   |  |  |    \
    |   -----------------    |  |  |     \
    |           |            |  |  |      \
    |        (wraps)         |  |  |       \
    |           |            |  |  |        \
    |      -------------------  |  |    ----------------------
    |     | DSTokenController | |  |   | DSTokenSupplyManager |
    |      -------------------  |  |    ----------------------
    |         |          |      |  |   /
    |       (has)      (has)    |  | (has)
    |         |          |      |  | /
  --------------       -------------
 | DSApprovalDB |     | DSBalanceDB |
  --------------       -------------


SOURCE CODE
===========

The source code can be found at <a href="https://github.com/ryepdx/the-tao">https://github.com/ryepdx/the-tao</a>.


DEPLOYMENT
==========

In order to help create new instances of "The TAO", there is an instance of a
contract called TheTAOFactory which can be used to create and set up instances
of "The TAO". Setting up an instance of "TheTAO" requires a few transactions to
this factory instance due to block gas limits.

First, the `createAuthority` function must be called. This creates and returns
the address of your "The TAO" instance's root authority. It takes no parameters.

```
factory.createAuthority()
```

The authority returned is owned by the factory contract. As such, you may choose
to immediately set up your token contracts by passing the authority to the
`createToken` function. It takes the authority's address as a parameter and
returns a pair of addresses: the token frontend followed by the token supply
manager.

```
factory.createToken(root_authority)
```

The `createToken` contract will only succeed if the factory is set as the owner
of the root authority. When it returns the root authority, it maintains
ownership. If you want to take ownership of the root authority directly from the
factory, you may pass it to the `giveOwnership` function. You'll need to use the
`updateAuthority` function on the root authority to give ownership back to the
factory if you later choose to use `createToken` or `setupMultisig`.

Once the token is set up and ownership of the root authority has been returned
(if you called `giveOwnership`) to the factory, you may set up a simple multisig
contract to govern your instance of "The TAO".

```
factory.setupMultisig(root_authority, 2, 3, 72*60*60)
```

The example above creates a 2-of-3 DSEasyMultisig instance with a 72 hour
voting window on proposals. This is not the sort of governance structure most
people have in mind when they think of a DAO, but it can be a good compromise
between centralization and decentralization in a DAO's early days. It ensures
one person cannot unilaterally make decisions without introducing too much
friction around taking the sort of quick action that may be needed in a DAO's
early days. If a dictatorship suits you better, of course, you may choose to
just call `giveOwnership(root_authority)` to claim personal ownership instead.
More imaginative forms of governance may be instituted by giving ownership of
the root authority to other kinds of proxy contracts.

The `setupMultisig` function returns the address of the new DSEasyMultisig
contract and gives ownership of the root authority to the new multisig. Once
created, it must be populated with its members by calling `addMember`. New
members may not be removed once added, and new members may not be added after
all the positions have been filled. To remove members or otherwise change
membership, the multisig may give ownership of the root authority to a contract
which passes ownership on to the factory, calls `setupMultisig`, calls
`addMember` for each of the members of the new multisig, and sets the new
multisig as the owner of the root authority.


FACTORY INSTANCE ADDRESS AND ABI
================================

TheTAOFactory address:
0x594c55db3e6df7b66b35974cc3ccdeef27318be2

TheTAOFactory testnet address:
0x8a57ef2c492e4fa698fd8f85490a697b5d9d97c5

TheTAOFactory ABI:
[{"constant": false, "inputs": [{"name": "authority", "type": "address"},
{"name": "n", "type": "uint256"}, {"name": "m", "type": "uint256"}, {"name":
"exp", "type": "uint256"}], "name": "setupMultisig", "outputs": [{"name": "",
"type": "address"}], "type": "function"}, {"constant": false, "inputs": [],
"name": "createAuthority", "outputs": [{"name": "", "type": "address"}], "type":
"function"}, {"constant": false, "inputs": [{"name": "authority", "type":
"address"}], "name": "createToken", "outputs": [{"name": "", "type": "address"},
{"name": "", "type": "address"}], "type": "function"}, {"constant": false,
"inputs": [{"name": "authority", "type": "address"}], "name": "giveOwnership",
"outputs": [], "type": "function"}, {"inputs": [{"name": "factory", "type":
"address"}], "type": "constructor"}]


STYLIZATION
===========

The quotes in "The TAO"'s name are intentionally part of the name. Any reference
to The TAO (without quotes) should be understood and interpreted as referring to
<a href="http://www.taoism.net/ttc/complete.htm">The Tao Te Ching</a>. (Cluing in the offender as to what's going on is, of course,
optional...)


CONTRACT LISTING
================

* <a href="https://github.com/nexusdev/dappsys/blob/develop/contracts/gov/easy_multisig.sol">DSEasyMultisig</a>
* <a href="https://github.com/nexusdev/dappsys/blob/develop/contracts/auth/basic_authority.sol">DSBasicAuthority</a>
* <a href="https://github.com/nexusdev/dappsys/blob/develop/contracts/token/frontend.sol">DSTokenFrontend</a>
* <a href="https://github.com/nexusdev/dappsys/blob/develop/contracts/token/controller.sol">DSTokenController</a>
* <a href="https://github.com/nexusdev/dappsys/blob/develop/contracts/data/approval_db.sol">DSApprovalDB</a>
* <a href="https://github.com/nexusdev/dappsys/blob/develop/contracts/data/balance_db.sol">DSBalanceDB</a>
* <a href="https://github.com/nexusdev/dappsys/blob/develop/contracts/token/supply_manager.sol">DSTokenSupplyManager</a>


DISCLAIMER
==========

The code and methods discussed in this document come with no guarantees of
fitness for use and may do anything including eating your laundry or losing
millions in your token holders' ether. Use at your own risk.


RAMBLING RHETORIC
=====================

"The TAO" is, as you might suspect, somewhat meant to be a critique of "The
DAO." Many consider "The DAO" too big to fail, so I created a simple platform
for creating many DAOs which may function as a single unit if they so choose. By
making each DAO issue its own tokens by default, though, I hope to encourage
keeping the risk inherent in each DAO's approach decoupled from the rest.

Whereas "The DAO" offered shiny marketing materials in an attempt to attract as
many people as possible, "The TAO" offers only plaintext. Whereas "The DAO"
offered a single governance mechanism, "The TAO" only offers a bootstrapping
mechanism, leaving governance mechanisms to be implemented by the community on a
case-by-case basis. Whereas "The DAO" was very clearly an organization held
together by a common profit motive, "The TAO" is held together only by the
theoretical interoperability of any components built for it and may not, in
fact, be an organization at all.

"""
The Tao that can be spoken is not the eternal Tao
The name that can be named is not the eternal name
The nameless is the origin of Heaven and Earth
The named is the mother of myriad things
Thus, constantly without desire, one observes its essence
Constantly with desire, one observes its manifestations
These two emerge together but differ in name
The unity is said to be the mystery
Mystery of mysteries, the door to all wonders
"""
